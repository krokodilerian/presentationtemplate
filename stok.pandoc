% stateless auth tokens
% елементарен трик
% Васил Колев <vasil@ludost.net>

# Проблемът

## Често срещана практика

* нужен token за нещо
    + login
    + код за reset на парола
    + като цяло нещо, което да пратим и да удостовери, че че отсрещната страна го е получила
* генерира се random и се пише в таблица
* безсмислено действие
* подлежи на DoS

<!--
(този трик вероятно има някакво стандартно име, което аз не знам, цялата лекция ми хрумна една вечер докато не можех да спя и така и не се зарових)

Много често ни се налага да генерираме token/код, който да изпратим на някой потребител (по страничен канал), за да се удостовери. Едно често срещано решение е да се генерира нещо съвсем random, което обаче води до пазене на твърде много state и много често не е практически възможно.
-->

# Решението

## просто решение - подпис с криптографски hash/hash mac

* \$userid.\$timestamp.\$somethingelse.\$sign
* \$sign = HMAC(\$userid.\$timestamp.\$somethingelse.\$secret)
    + somethingelse може да се ползва за salt, за допълнителна сигурност
* проверява се се тривиално
* не изисква state
* не подлежи на DoS-ове

<!--
Проблемът има просто решение, чрез криптографски (hash) подписан token, от който може да се извади цялата информация, без да е нужно да се гледа някакъв state. Генерира се тривиално, като до информацията се долепя един HMAC подпис с някакъв secret, който ви е познат на вас.
(hmac е метод за прилагане на hash функция, например sha1. Не е добра идея да се използва директно SHA1 или нещо от същото семейство, понеже подлежи на lengthening атака, но може да се ползва SHA3)

Така тази информация се проверява тривиално, и не изисква да пазите каквото и да е и да могат да ви препълнят някакви таблици, да генерират писания в базата и т.н.
-->

## Инвалидация на token

* Автоматично от timestamp-а и изтичане на дадения живот на token-а
* За login - HMAC($userid.$password.$secret)
    + смяната на паролата инвалидира token-а
* по-генерално решение - пазим кога е издаден последният валиден token
    + налага се да държим state, но е по-малко
* replay атаки?

<!--
Схемата има един проблем - няма прост начин да се инвалидира. За това има няколко различни workaround-а:
Имаме timestamp, при който знаем кога изтича token-а и като цяло го правим да е валиден за кратко.
Слагаме в него нещо, което потребителя може да промени и така да го инвалидира (например паролата му, чрез смяната и може да ги направи невалидни).
Можем и да пазим кога последно сме генерирали token и да не признаваме по-стари (или по-нови) такива.
В общи линии последните две неща ни карат да питаме външен източник, когато проверяваме token-а, но пак ми дават възможност да държим много по-малко state.
-->


# Примери

## VERP 

* измислен от DJB
* https://en.wikipedia.org/wiki/Variable_envelope_return_path

<!--
За всички, които трябва да пращат поща и да знаят дали адресът не е bounce-нал - проста схема, в която пишем в Return-path: адресът, на който сме пратили писмото и по отговорите на този адрес знаем кой точно не се е получил. Към това лесно се добавя един прост подпис, така че да не се получават случайни писма при някакво глупаво изчерпване.
-->

## TCP Syncookies

* също измислено от djb
* https://en.wikipedia.org/wiki/Syncookies

<!--
Вече default на всички tcp/ip стекове. Идеята е съвсем проста - ISN (initial sequence number) на сесията, който връщаме в SYN+ACK пакета представлява hash на secret и още няколко неща, така че когато получим третия пакет от handshake, можем да сме сигурни, че този клиент е искал да се свърже с нас.
(За повече подробности потърсете за SYN flood и защита от него).
-->

## client-side session

* Всичко в сесията + подпис + timestamp
* на сървъра - само последен timestamp на промяна на сесията
* ползва се например в rails

<!--
Също така можем да спестим място от потребителски сесии - можем да пазим само последен timestamp и нищо друго, а самата сесия да е в cookie при потребителя и да не ни интересува. Така можем да сме сигурни, че ние сме му я подали и че не съдържа нещо, което не сме искали.
-->

