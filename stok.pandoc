% stateless auth tokens
% елементарен трик
% Васил Колев <vasil@ludost.net>

# Проблемът

## Често срещана практика

* нужен token за нещо
    + login
    + код за reset на парола
    + като цяло нещо, което да пратим и да удостовери, че че отсрещната страна го е получила
* генерира се random и се пише в таблица
* безсмислено действие
* подлежи на DoS

<!--
Много често ни се налага да генерираме token/код, който да изпратим на някой потребител (по страничен канал), за да се удостовери. Едно често срещано решение е да се генерира нещо съвсем random, което обаче води до пазене на твърде много state и много често не е практически възможно.
-->

# Решението

## просто решение - подпис с криптографски hash

* \$userid.\$timestamp.\$somethingelse.\$sign
* \$sign = sha1(\$userid.\$timestamp.\$somethingelse.\$secret)
    + somethingelse може да се ползва за salt, за допълнителна сигурност
* проверява се се тривиално
* не изисква state
* не подлежи на DoS-ове

<!--
Проблемът има просто решение, чрез криптографски (hash) подписан token, от който може да се извади цялата информация, без да е нужно да се гледа някакъв state. Генерира се тривиално...
-->

# Инвалидация на token

* Автоматично от timestamp-а и изтичане на дадения живот на token-а
* За login - sha1($userid.$password.$secret)
    + смяната на паролата инвалидира token-а
* по-генерално решение - пазим кога е издаден последният валиден token
    + налага се да държим state, но е по-малко
* replay атаки?

<!--
още малко неща, дето ще допиша
-->


# Примери

<!--
И примери
-->

## VERP 

* измислен от DJB
* https://en.wikipedia.org/wiki/Variable_envelope_return_path

<!--
За всички, които трябва да пращат поща и да знаят дали адресът не е bounce-нал.
-->

## TCP Syncookies

* също измислено от djb
* https://en.wikipedia.org/wiki/Syncookies

<!--
Вече default на всички tcp/ip стекове.
-->

## client-side session

* Всичко в сесията + подпис + timestamp
* на сървъра - само последен timestamp на промяна на сесията

<!--
Да спестим място от потребителски сесии.
-->


