% stateless auth tokens
% елементарен трик
% Васил Колев <vasil@ludost.net>


# Често срещана практика

* нужен token за нещо
    + login
    + код за reset на парола
    + като цяло нещо, което да пратим и да удостовери, че че отсрещната страна го е получила
* генерира се random и се пише в таблица
* безсмислено действие
* подлежи на DoS

<!--
Много често ни се налага да генерираме token/код, който да изпратим на някой потребител (по страничен канал), за да се удостовери. Едно често срещано решение е да се генерира нещо съвсем random, което обаче води до пазене на твърде много state и много често не е практически възможно.
-->

# просто решение - подпис с криптографски hash

* \$userid.\$timestamp.\$somethingelse.\$sign
* \$sign = sha1(\$userid.\$timestamp.\$somethingelse.\$secret)
    + somethingelse може да се ползва за salt, за допълнителна сигурност
* проверява се се тривиално
* не изисква state
* не подлежи на DoS-ове

<!--
Проблемът има просто решение, чрез криптографски (hash) подписан token, от който може да се извади цялата информация, без да е нужно да се гледа някакъв state. Генерира се тривиално...
-->

# Инвалидация на token

* Автоматично от timestamp-а и изтичане на дадения живот на token-а
* За login - sha1($userid.$password.$secret)
    + смяната на паролата инвалидира token-а
* по-генерално решение - пазим кога е издаден последният валиден token
    + налага се да държим state, но е по-малко
* replay атаки?

<!--
още малко неща, дето ще допиша
-->

# места, на които се използва

* VERP на DJB
* TCP Syncookies
* client-side session
* всичките auth token-и при нас

<!--
И примери
-->
